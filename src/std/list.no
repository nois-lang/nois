use std::iter::{ Iter, Iterable, Collector }

type List<T>

impl <T> List<T> {
    fn at(self, index: Int): Option<T> {
        listAt(self, index)
    }

    fn add(self, item: T): Unit {
        listAdd(self, item)
    }
}

impl <T> Iterable<T> for List<T> {
    fn iter(self): ListIter<T> {
        ListIter::ListIter(list: self, index: 0)
    }
}

impl <T> Collector<T> for List<T> {
    fn fromIter(iter: Iter<T>): Self {
        let list = []
        // TODO: replace with while let
        while true {
            match iter.next() {
                Option::Some(value) {
                    list.add(value)
                },
                Option::None() { break },
            }
        }
        list
    }
}

impl io::Display for List<String> {
    fn fmt(self): String {
        let string = "["
        for s in self {
            // TODO: impl addMut() 
            string = string.concat(s)
        }
        string.concat("]")
    }
}

impl <T: io::Display> io::Display for List<T> {
    fn fmt(self): String {
        // TODO: better generic resolution
        // self.iter().map(io::Display::fmt).collect<List>().fmt()
    }
}

type ListIter<T>(
    list: List<T>,
    index: Int,
)

impl <T> Iter<T> for ListIter<T> {
    fn next(self): Option<T> {
        match self.list.at(self.index) {
            Option::Some(value) {
                self.index = self.index + 1
                Option::Some(value)
            },
            _ { Option::None() }
        }
    }
}

fn listAt<T>(list: List<T>, index: Int): Option<T>

fn listAdd<T>(list: List<T>, item: T): Unit

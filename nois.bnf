module              ::= statement*
                    ;
statement           ::= var-def | fn-def | kind-def | impl-def | type-def | return-stmt | expr
                    ;
  var-def           ::= LET-KEYWORD pattern type-annot? EQUALS expr
                    ;
  fn-def            ::= FN-KEYWORD type-expr params? type-annot? block?
                    ;
  kind-def          ::= KIND-KEYWORD type-expr block
                    ;
  impl-def          ::= IMPL-KEYWORD type-expr impl-for? block
                    ;
    impl-for        ::= FOR-KEYWORD type-expr
                    ;
  type-def          ::= TYPE-KEYWORD type-expr (type-con-list | type-con-params?)
                    ;
    type-con-params ::= O-PAREN (field-def (COMMA field-def)*)? COMMA? C-PAREN
                    ;
      field-def     ::= IDENTIFIER type-annot
                    ;
    type-con-list   ::= O-BRACE (type-con (COMMA type-con)* COMMA?)? C-BRACE
                    ;
      type-con      ::= IDENTIFIER type-con-params?
                    ;
  return-stmt       ::= RETURN-KEYWORD expr?
                    ;
  expr              ::= sub-expr (infix-op sub-expr)*
                    ;
    sub-expr        ::= prefix-op operand | operand postfix-op?
                    ;
      operand       ::= if-expr
                    | lambda-expr
                    | O-PAREN expr C-PAREN
                    | STRING
                    | CHAR
                    | NUMBER
                    | IDENTIFIER
                    | type-expr
                    ;
    infix-op        ::= add-op | sub-op | mul-op | div-op | exp-op | mod-op | access-op | eq-op | ne-op
                    | ge-op | le-op | gt-op | lt-op | and-op | or-op;
      add-op        ::= PLUS;
      sub-op        ::= MINUS;
      mul-op        ::= ASTERISK;
      div-op        ::= SLASH;
      exp-op        ::= CARET;
      mod-op        ::= PERCENT;
      access-op     ::= PERIOD;
      eq-op         ::= EQUALS EQUALS;
      ne-op         ::= EXCL EQUALS;
      ge-op         ::= C-ANGLE EQUALS;
      le-op         ::= O-ANGLE EQUALS;
      gt-op         ::= C-ANGLE;
      lt-op         ::= O-ANGLE;
      and-op        ::= AMPERSAND AMPERSAND;
      or-op         ::= PIPE PIPE;

    prefix-op       ::= add-op | sub-op | not-op | spread-op
                    ;
      not-op        ::= EXCL
                    ;
      spread-op     ::= PERIOD PERIOD
                    ;

    postfix-op      ::= call-op | con-op
                    ;
      call-op       ::= args
                    ;
        args        ::= O-PAREN (expr (COMMA expr)*)? COMMA? C-PAREN
                    ;
      con-op        ::= O-PAREN (field-init (COMMA field-init)*)? COMMA? C-PAREN
                    ;
        field-init  ::= IDENTIFIER COLON expr
                    ;
    lambda-expr     ::= lambda-params type-annot? (block | expr)
                    ;
      lambda-params ::= PIPE (param (COMMA param)*)? COMMA? PIPE
                    ;
    params          ::= O-PAREN (param (COMMA param)*)? COMMA? C-PAREN
                    ;
        param       ::= pattern type-annot?
                    ;
block               ::= O-BRACE statement* C-BRACE
                    ;
type-annot          ::= COLON type-expr
                    ;
  type-expr         ::= IDENTIFIER type-params?
                    ;
    type-params     ::= O-ANGLE (type-expr (COMMA type-expr)* COMMA?)? C-ANGLE
                    ;
if-expr             ::= IF-KEYWORD expr block (ELSE-KEYWORD block)?
                    ;
pattern             ::= con-pattern | IDENTIFIER | hole
                    ;
  con-pattern       ::= IDENTIFIER con-pattern-params
                    ;
  con-pattern-params::= O-PAREN (field-pattern (COMMA field-pattern)*)? COMMA? C-PAREN
                    ;
    field-pattern   ::= IDENTIFIER (COLON pattern)? | spread-op
                    ;
  hole              ::= UNDERSCORE
                    ;
